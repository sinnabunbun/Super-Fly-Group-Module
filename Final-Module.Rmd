---
title: "Phylogenetic Comparison between Molecular and Morphological Trees"
author: "Abby Robinson, Isabel Novick, Marta Hammers"
date: "11/5/2021"
output: 
  html_document:
    toc: true
    toc_float: true
    css: bootstrap.css
    number_sections: TRUE
---

```{r setup, include=FALSE, error = TRUE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<style>
div.blue pre { background-color:navy; }
div.blue pre.r { background-color:navy; }
</style>

<p class="text-primary">In our module we want to explore how we can build and plot phylogenetic trees based on molecular and morphological criteria and how to compare these trees statistically.</p>

## Objectives

1. Practice writing and plotting trees in Newick format 
2. Load phylogenetic tree data into R and plot in baseR and ggtree 
3. Compare tree topologies 

## Introduction 

Evolutionary biologists study the ways organisms change over time. This is often done by comparing several species to one another and analyzing the differences between them. These differences can then be used to build a graphical representation of species’ relationships to one another, called a phylogenetic tree. Originally, these trees were constructed based solely on organism morphology using shared derived traits, or __synapomorphies__, often in the form of character matrices. By focusing on these physical traits, biologists could hypothesize different life histories, like species divergence or common descent. However, using morphological data to determine taxonomic relationships is not foolproof. Some shared, analogous traits may be due to convergent evolution. Homoplasy can be difficult to detect through morphological analysis alone, and has historically resulted in phylogenetic trees that have since been disproved through the use of molecular data.
	
Modern biologists can now build phylogenetic trees based on the DNA of the organisms in question. By focusing on a few specific genes, evolutionary relationships can be hypothesized with greater accuracy. Examining the polymorphism at different loci can provide information on how distantly related organisms are to one another, and can reduce errors commonly associated with comparing or identifying cryptic species. Molecular data can help resolve unclear phylogenies that were created before genomic methods were available. Biologists can now revisit unresolved trees built from morphological data and revise them using DNA, allowing us to better hypothesize evolutionary relationships.
	
In order to assess any changes between these hypothesized evolutionary relationships, we can compare the topologies of phylogenetic trees. The topology refers to the branching pattern displayed, which represents the measure of relatedness among taxa. To understand the importance of topology, we must familiarize ourselves with the anatomy of a phylogenetic tree. 

<h4><p class="text-primary">Anatomy of a tree:</p></h4>  
![__Why would we compare tree topologies?__](https://media.springernature.com/full/springer-static/image/art%3A10.1007%2Fs12052-008-0035-x/MediaObjects/12052_2008_35_Fig2_HTML.gif?as=webp)

# Methods

There are several different ways to estimate phylogenies, each with their own strengths, weaknesses, and appropriate situations in which to apply them. While we won’t go over them in detail, familiarize yourselves by looking at <a href="https://fuzzyatelin.github.io/bioanth-stats/module-24/module-24.html)">Module 24</a>  
There are MANY different phylogenetics software that we can use to employ these methods of estimation, but some of the most common are PAUP, BEAST, MrBayes, and PHYLIP. These can take genetic data (alignments) in the form of fastq files, fasta files, or NEXUS files.  

<h4><p class="text-primary">Types of Tree Formats: Newick, Nexus</p></h4>

There are several different formats that a graphical tree can be built from.    
_Newick_: A collection of data formatted using specific syntax that includes parentheses, commas, and semicolons to delineate weight, time, and evolutionary distance. “Newick files are simply text files that consist of one or more tree descriptions in the Newick notation. In contrast to Nexus files they contain no further syntax elements or other information than the trees.”

# Comparing Trees

We will be comparing two graphical hypotheses of the genus _adelpha_, a group of butterflies.
![image](https://onlinelibrary.wiley.com/cms/asset/1d72eca6-ecb9-4b23-8230-868514c2fa01/mec13168-fig-0001-m.jpg)

In this module, we will compare tree topologies for two different analyses of the genus Adelpha; one based on morphological data and the other based on molecular data. The morphological-based tree is from Keith Wilmott’s 2003 paper [“Cladistic analysis of the Neotropical butterfly genus Adelpha (Lepidoptera: Nymphalidae), with comments on the subtribal classification of Limenitidini.”](https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-3113.2003.00209.x) Our molecular tree is from Emily Ebel’s 2015 paper [“Rapid diversification associated with ecological specialization in Neotropical Adelpha butterflies.”](https://onlinelibrary.wiley.com/doi/10.1111/mec.13168)

# Packages

>For starters, you will need to install [{ape}](https://www.rdocumentation.org/packages/ape/versions/5.5), [{phytools}](https://www.rdocumentation.org/packages/phytools/versions/0.7-90)
[{fastmatch}](https://cran.r-project.org/web/packages/fastmatch/index.html)
[{quadprog}](https://cran.r-project.org/web/packages/quadprog/index.html)
[{phangorn}](https://www.rdocumentation.org/packages/phangorn/versions/2.7.1)
[{geiger}](https://www.rdocumentation.org/packages/geiger/versions/2.0.7)
[{ggplot2}](https://www.rdocumentation.org/packages/ggplot2/versions/3.3.5)
[{ggtree}](https://www.rdocumentation.org/packages/ggtree/versions/1.4.11)

Unlike many packages we've used this semester, you will need to install ggtree from the BiocManager, not baseR. You can do this using the code below 

<div class = "blue">
```{r} 
 if (!requireNamespace("BiocManager", quietly = TRUE))
+     install.packages("BiocManager")
 BiocManager::install("ggtree")
```
</div>
Once all our packages are installed, we can load them into our R markdown file! 
<div class = "blue">
```{r}
library(ape)
library(fastmatch)
library(quadprog)
library(phangorn)
library(phytools)
library(geiger)
library(ggplot2)
library(ggtree)
```
</div>
For these packages to work effectively with the code below, its important to make sure you're using the most up-to-date versions. 

You can check that you have the most up-to-date version of R by running the command "R.Version"
<div class = "blue">
```{r}
R.version
```
</div>
You can make sure you have the most up-to-date version of each package by using the command "packageVersion("package-name")
<div class = "blue">
```{r}
packageVersion("ape")
```
</div>
	
## Building Trees in Newick Notation 

To start off, we want to understand how a tree is created. For this example we will make our own tree using Newick format.

Here is a great explanation of Newick format: __"Put simply, monophyletic clades are surrounded by parentheses and sister clades are separated by commas. For example, a simple tree could be written as (((A,B),C),(D,E))."__ Let's try making that!

### CHALLENGE 1
If you already know the relationships between the groups of species that you want to plot, you can simply write out the tree as a text string in Newick format! Let's try it first with letters. Try to recreate the tree in the image below by writing it as a text string in Newick format 

![image](https://raw.githubusercontent.com/sinnabunbun/Super-Fly-Group-Module/main/abcs.jpg)

#### SOLUTION 1 

Once we have the tree written in Newick notation, we can use the command "read.tree()" to read the text string into R as a phylogenetic tree. Once we have a tree, we can plot it using the "plot()" command 
<div class = "blue">
```{r set-up}
text.string<-
    "(((A,B),C),(D,E));"
example.tree<-read.tree(text=text.string)
plot(example.tree,no.margin=TRUE,edge.width=2) 
```  
</div>
	
### CHALLENGE 2

Hey! Guess What?? Whales are cool! 
![image](https://raw.githubusercontent.com/sinnabunbun/Super-Fly-Group-Module/main/image.png)

For our second challenge, try recreating the whale clade in the image below using Newick notation and the read.tree() function 

![image](https://raw.githubusercontent.com/sinnabunbun/Super-Fly-Group-Module/main/whales.jpg)

#### SOLUTION 1

Great Job! 
<div class = "blue">
```{r animals}
text.string<-
    "((((humpback wahle, fin whale), (Antarctic minke whale, common minke whale)), bowhead whale), sperm whale);"
whale.tree<-read.tree(text=text.string)
plot(whale.tree,no.margin=TRUE,edge.width=2)
``` 
</div>
	
## Visualizing Trees in baseR

There are many different commands that will allow you to visualize your tree. Let's try a few a few in baseR! 
<div class = "blue">
```{r}
roundPhylogram(whale.tree) #creates rounded branches 
```
</div>
The tree we wrote in Newick format is rooted, but we can unroot it in our plot using the code below 
<div class = "blue">
```{r}
plot(unroot(whale.tree),type="unrooted",no.margin=TRUE,lab4ut="axial",
    edge.width=4) #creates an unrooted tree 
```
</div>
We can also make a fan tree! the command "edge.width" allows you to adjust the thickness of tree branches, and you can use "show.tip.label" to remove the tip labels. 
<div class = "blue">
```{r}
plot(whale.tree, type = "fan", edge.width = 3, show.tip.label = FALSE)
```
</div>

### CHALLENGE 3

Try using the plot() function to plot our whale tree as a phylogram with different branch and tip label colors 

#### SOLUTION 3
<div class = "blue">
```{r}
plot(whale.tree, type = "phylogram",  edge.color = "red")
```
</div>	
<div class = "blue">	
```{r}
plot(whale.tree, type = "phylogram",  edge.color = "red", tip.color = "green")
```
</div>
<div class = "blue">
```{r}
plot(whale.tree, type = "phylogram",  edge.color = "red", tip.color = "green", font = 4)
```
</div>
	
# Load Molecular Tree Data

Now that we are a little more comfortable working with phylogenetic trees in R, we can load our first tree! 

First, copy the tree data at [{This Link}](https://raw.githubusercontent.com/sinnabunbun/Super-Fly-Group-Module/main/NJst.tre) 
Then go to your own working repo, select the "Create New File" option and paste the tree data into that file.  

Once you have the tree file saved in your repo, you can load the tree into your R markdown file using the "read.nexus" command 
<div class = "blue">
```{r}
mol.tree<-read.nexus(file="NJst.tre")
mol.tree
```
</div>
Once the tree is loaded, we can try plotting it! 
<div class = "blue">
```{r}
par(mfrow = c(2, 3))
phy <- plot(mol.tree, type = "phylogram",  edge.color = "purple", font = 1, show.tip.label = FALSE)
phy

unroot <- plot(unroot(mol.tree),type="unrooted",cex=0.6,
    use.edge.length=FALSE,lab4ut="axial",
    no.margin=TRUE, show.tip.label = FALSE, edge.color = "red")
unroot

radial <- plot(mol.tree, type = "radial",  edge.color = "green", tip.color = "black", font = 1, show.tip.label = FALSE)
radial

fan <- plot(mol.tree, type = "fan",  edge.color = "blue", tip.color = "black", font = 1, show.tip.label = FALSE)
fan

clade <- plot(mol.tree, type = "cladogram",  edge.color = "orange", tip.color = "black", font = 1, show.tip.label = FALSE)
clade
```
</div>
the Ntip() function will tell you how many different species (or tips) are represented in your tree 
<div class = "blue">
```{r}
Ntip(mol.tree) ##66 species in this tree
```
</div>
To generate a list of species names, use mol.tree$tip.label
<div class = "blue">
```{r}
##all the species names 
mol.tree$tip.label
```
</div>
	
### CHALLENGE 4 

A great way to draw attention to a specific species in a tree plot is to add an arrow pointing to a specific species. Now that you can see all the species names, pick a species and use add.arrow() to draw an arrow to it! 

#### SOLUTION 4

<div class = "blue">
```{r}
##add an arrow on a specific branch tip 
plot(mol.tree)
add.arrow(mol.tree,tip="A_saundersii_saundersii",arrl=4)
```
</div>

With nexus trees, you can also create node labels. This is especially useful if you want to highlight a specific node. 
<div class = "blue">
```{r}
plot(mol.tree,no.margin=TRUE,edge.width=2)
nodelabels(text=1:mol.tree$Nnode,node=1:mol.tree$Nnode+Ntip(mol.tree))
```
</div>
<div class = "blue">
```{r}
plot(mol.tree, "fan", main="Molecular Tree", edge.width = 3, edge.color = "pink", show.tip.label = FALSE)
arc.cladelabels(tree=mol.tree, "A. rothschildi", node = 4, cex=1, orientation="curved")
```
</div>

## Morphological Tree

In order to compare molecular and morphological trees of the Adelpha lineage, we needed to build a tree in R from a phylogeny constructed based on morphological data, like the one reported in Keith Wilmott's paper. However, because this tree was created in 2003 and is therefore not in a format that is easily compatible with current R software, we ended up transcribing the tree into R in Newick format based on the phylogenetic relationships presented in Wilmott's Figure 8. 
<div class = "blue">
```{r}
string <- "((A_alala_negra, A_corcyra_aretina, A_tracta, A_pithys, A_donysa_donysa), ((A_serpacelerio, A_seriphiaaquillia, A_seriphiatherasia), (A_melonaleucocoma, A_salmoneus_colada, A_cytherea_cytherea, A_cythereadaguana, A_epioneagilla, A_etheldaethelda, A_thessaliathessalia, A_iphicleolathessalita, A_iphiclusiphiclus, A_shuara, A_plesaurephliassa, A_basiloides, A_atticaattica, A_leucerioides, A_saundersiisaundersii, A_boreasboreas, A_rothschildi, A_sichaeus, A_cocalacocala, A_leucophthalmairminella, A_irminatumida, A_pollina, A_lycoriaslara, A_lycoriasspruceana, A_erotia_erotia, A_mesentina, A_phylaca_pseudaethalia, A_capucinus_capucinus, A_heraclea_heraclea, A_naxia_naxia, A_justina_valentina, A_olynthia, A_jordani, A_zinazina, A_zinairma, A_delinita_delinita, A_boeotia_boeotia, A_maleaaethalia)));"

morph.tree<-read.tree(text=string)
plot(morph.tree,no.margin=TRUE,edge.width=2)
```
</div>
<div class = "blue">
```{r}
par(mfrow = c(2, 3))
phy2 <- plot(morph.tree, type = "phylogram",  edge.color = "purple", font = 1, show.tip.label = FALSE)
phy2

unroot2 <- plot(unroot(morph.tree),type="unrooted",cex=0.6,
    use.edge.length=FALSE,lab4ut="axial",
    no.margin=TRUE, show.tip.label = FALSE, edge.color = "red")
unroot2

radial2 <- plot(morph.tree, type = "radial",  edge.color = "green", tip.color = "black", font = 1, show.tip.label = FALSE)
radial2

fan2 <- plot(morph.tree, type = "fan",  edge.color = "blue", tip.color = "black", font = 1, show.tip.label = FALSE)
fan2

clade2 <- plot(morph.tree, type = "cladogram",  edge.color = "orange", tip.color = "black", font = 1, show.tip.label = FALSE)
clade2
```
</div>

## Modifying trees with ggtree

You can also plot these trees using the ggplot2 and ggtree packages 
<div class = "blue">
```{r}
#Morphological tree plot
library(ggtree)
p <- ggtree(morph.tree, color="purple", size=0.5)
p <- p + geom_tiplab(size=2)
p
```
</div>
<div class = "blue">
```{r}
#Molecular tree plot 
g <- ggtree(mol.tree, color="green", size=0.5)
g <- g + geom_tiplab(size=2)
g
```
</div>
<div class = "blue">
```{r}
library("gridExtra")
grid.arrange(
    ggtree(mol.tree, color="red") + theme_tree("steelblue"),
    ggtree(morph.tree, color="white") + theme_tree("black"),
    ncol=2)
```
</div>

## Comparison

Now we will get into comparing our morphological tree and our molecular tree. First we will use the function all.equal from the APE package. This is a good place to start when comparing trees because it will tell you the basics: are these trees the same?
<div class = "blue">	
```{r}            
all.equal(mol.tree, morph.tree, use.edge.length = TRUE,
                   use.tip.label = TRUE)
```
</div>
It's a good exploratory function, but after we learn that they are not the same, we have to dig deeper.

Let's see if the trees are ultrametric.
<div class = "blue">
```{r}#fix for knit
is.ultrametric(mol.tree)
##is.ultrametric(morph.tree) ? 
```
</div>
This will tell you that the molecular tree is __NOT ultrametric__, which means the tips of the tree are not equally distant from the root of their respective tree. We get an error about the morphological tree's lack of branch lengths, so let's try a different function that will give us more information.

When both trees are non-ultrametric, we are limited to the number of analyses that we can perform.

Next we'll try comparing phylogenetic tree topographies using the comparePhylo function from the APE package.
<div class = "blue">
```{r}
comparePhylo(morph.tree, mol.tree, plot = FALSE, force.rooted = FALSE,
             use.edge.length = FALSE)
```
</div>
The morphological tree is also non-ultrametric. Essentially, both trees have structure and are not one big polytomy, and branch lengths differ, although one phylogeny is more structured than the other. Can you tell which one it is? 

It also tells us that they have different numbers of tips (46 and 66) which makes sense because they aren't looking at the same number of individuals. Naturally because of this, these trees will inherently be different from each other structurally. The morph tree has fewer nodes not only because it's hypothesizing the relationships among fewer individuals, but also because there is more uncertainty. This tree is comb like, and we can interpret this as an unresolved phylogeny. 

When both trees are non-ultrametric, the number of analyses that we can perform is limited. Let's explore what more we can learn about these trees.

We can also see that the morphological tree is rooted and the molecular tree is unrooted. We can either go back and adjust the molecular tree to root it, or we can adjust our code to force root both trees and analyze the molecular tree as if it were rooted.
<div class = "blue">
```{r}
comparePhylo(morph.tree, mol.tree, plot = FALSE, force.rooted = TRUE, use.edge.length = FALSE)
```
</div>
This shows the number of clades that are different in each tree. As we can see, there are a lot more clades in the molecular tree than the morphological tree.

Check to see if they are binary. According to the APE package, "The test differs whether the tree is rooted or not. An urooted tree is considered binary if all its nodes are of degree three (i.e., three edges connect to each node). A rooted tree is considered binary if all nodes (including the root node) have exactly two descendant nodes, so that they are of degree three expect the root which is of degree 2." Our molecular tree is unrooted and our morphological tree is rooted, so keep that in mind.
<div class = "blue">
```{r}
is.binary(mol.tree)
is.binary(morph.tree)
```
</div>
Now, let's try to plot these trees and view the characters that they have in common. Let's use the package dendextend. You will get some errors about the mol.tree being non-ultrametric and the morph.tree having a branch length of zero, but keep going through to plot(prunedplot).
<div class = "blue">
```{r}#knit fix
library(ape)
library(phytools)
library(dendextend)
library(viridis)
library(dplyr)
library(phylogram)

tree1 <- mol.tree
tree1 <- midpoint.root(tree1)
tree2 <- morph.tree
##tree2 <- midpoint.root(tree2)
tree1 <- compute.brlen(tree1)
tree2 <- compute.brlen(tree2)
tree1<- as.dendrogram(tree1)
tree1
tree2<- as.dendrogram(tree2)

dndlist <- dendextend::dendlist(tree1, tree2)
prunedplot <- dendextend::tanglegram(dndlist, fast = TRUE, margin_inner = 1.8, lab.cex = 0.3, lwd = 
0.5, edge.lwd = 0.5, type = "r")

plot(prunedplot)
```
</div>
Now we can clearly see the associations between these trees and the individuals and how they were rearranged. You can go branch by branch and follow the shaded lines to view where they are on the opposite tree.

## Reduction

As you can see these trees are pretty large, the title is cut off in most views! Although in depth analysis might call for this many tip labels, we can also narrow down our species- which will help us narrow down what we're observing. __##This needs to be trimmed and I want to add teh code from abaove to link the trees once thats fixed for the knit__  
<div class="blue">
```{r}
reduced.species<-c("A.alalanegra", "A.atticaattica", "A.basiloides", "A.boeotiaboeotia", "A.boreasboreas", "A.capucinuscapucinus", "A.cocalacocala", "A.corcyraaretina", "A.cythereacytherea", "A.cythereadaguana", "A.delinitadelinita", "A.donysadonysa", "A.epioneagilla", "A.erotiaerotia", "A.heracleaheraclea", "A.iphicleolathessalita", "A.iphiclusiphiclus", "A.irminatumida", "A.jordani", "A.justinavalentina", "A.seriphiatherasia")
morph.reduced<-sapply(reduced.species,grep,morph.tree$tip.label)
morph.reduced
reduced.species<-morph.tree$tip.label[morph.reduced]
reduced.species
plotTree(morph.tree,type="fan",fsize=0.7,lwd=1,
    ftype="i")
add.arrow(morph.tree,tip=reduced.species,arrl=.5)
morph.tree.reduced<-drop.tip(morph.tree,
    setdiff(morph.tree$tip.label,reduced.species))
plotTree(morph.tree.reduced,ftype="i")
reduced.species.mol<-c("A_alala_negra", "A_attica_attica", "A_basiloides", "A_boeotia_boeotia", "A_boreas_boreas", "A_capucinus_capucinus", "A_cocala_cocala", "A_corcyra_aretina", "A_cytherea_cytherea", "A_cytherea_daguana", "A_delinita", "A_donysa_donysa", "A_epione_agilla", "A_erotia_erotia", "A_ethelda_ethelda", "A_heraclea", "A_iphicleola_thessalita", "A_iphiclus_iphiclus", "A_irmina_tumida", "A_jordani", "A_justina_valentina", "A_seriphia_therasia")
mol.reduced<-sapply(reduced.species.mol,grep,mol.tree$tip.label)
mol.reduced
reduced.species.mol<-mol.tree$tip.label[mol.reduced]
reduced.species.mol
plotTree(mol.tree,type="fan",fsize=0.7,lwd=1,
    ftype="i")
add.arrow(mol.tree,tip=reduced.species.mol,arrl=1)
mol.tree.reduced<-drop.tip(mol.tree,
    setdiff(mol.tree$tip.label,reduced.species.mol))
plotTree(mol.tree.reduced,ftype="i")
```
</div>

## Final Fixes

### Unsure about the following chunks:

```{r}
set.seed(1)

# modify tip labels
mol.tree$tip.label <- sub("t", "", mol.tree$tip.label, fixed = T)
morph.tree$tip.label <- sub("t", "", morph.tree$tip.label, fixed = T)

# create associations matrix 

association <- cbind(mol.tree$tip.label, morph.tree$tip.label)

# plot
cophyloplot(mol.tree, morph.tree, assoc = association, length.line = 4, space = 28, gap = 3)
```


